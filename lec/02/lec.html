<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Lec. 02: Data Types and Program Memory Layout</title>
<!-- 2015-08-17 Mon 17:09 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Adam Aviv">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../class.css" />
<link rel="stylesheet" type="text/css" href="../print.css" media="print" />
<div class="page-head">
SI485H: Stack Based Binary Exploits and Defenses (F15)
</div>
<hr>
<a href="../../index.html">Home</a> <a href="../../policy.html">Policy</a> <a href="../../cal.html">Calendar</a>  <a href="../../rsc/index.html">Resources</a>
<hr>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Lec. 02: Data Types and Program Memory Layout</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Numeric Data Types and Sign-ness</a>
<ul>
<li><a href="#sec-1-1">1.1. Basic Numeric Types</a></li>
<li><a href="#sec-1-2">1.2. Signed Numeric Values</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Pointers and Memory References</a>
<ul>
<li><a href="#sec-2-1">2.1. Pointers Basic</a></li>
<li><a href="#sec-2-2">2.2. Randomization of Memory</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Arrays and Strings</a>
<ul>
<li><a href="#sec-3-1">3.1. Array Values and Pointers are the same thing!</a></li>
<li><a href="#sec-3-2">3.2. Pointer Arithmetic</a></li>
<li><a href="#sec-3-3">3.3. Strings</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Program Memory Layout</a>
<ul>
<li><a href="#sec-4-1">4.1. Cowboys and Endian-s</a></li>
<li><a href="#sec-4-2">4.2. Stack, Heap, Data, BSS</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Numeric Data Types and Sign-ness</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Basic Numeric Types</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Let's recall the basic data types for C programs. One thing to
consider is that we are going to be working with 32-bit architectures
as opposed to 64-bit ones. This is mostly to keep things simple for
the exploits, but it does mean some things may be a bit different at
times.
</p>

<p>
For example, consider this program and its output with the basic
numeric types.
</p>

<div class="org-src-container">

<pre class="src src-c" id="datatypes.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span> = 0xef;
  <span style="color: #98fb98;">short</span> <span style="color: #eedd82;">s</span> = 0xbeef;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0xdeadbeef;
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">l</span> = 0xcafebabe;

  printf(<span style="color: #ffa07a;">"char c=%d size=%u\n"</span>,c,<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">char</span>));
  printf(<span style="color: #ffa07a;">"short s=%d size=%u\n"</span>,s,<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">short</span>));
  printf(<span style="color: #ffa07a;">"int i=%d size=%u\n"</span>,i,<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
  printf(<span style="color: #ffa07a;">"long l=%ld size=%u\n"</span>,l,<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span>));

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<pre class="example">
user@si485H-base:demo$ ./datatypes
char c=-17 size=1
short s=-16657 size=2
int i=-559038737 size=4
long l=-889275714 size=4
</pre>

<p>
Notice that the long number is the same size as an integer, 4-bytes,
as opposed to 8-bytes on 64 bit machines. This is because the
registers on 32 bit machines are 32 bits wide, and storing 8-byte
values is annoying, at best. You can still have 8-byte values, but you
have to use <code>long long</code>.
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Signed Numeric Values</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The basic numeric types are also signed, that is, their range of values go
from [ -2<sup>(w-1)</sup> : 2<sup>(w-1)</sup>-1 ] because one of the bits is used to
indicate the sign. The signed bit is the leading one, if it is 1 then
the number is negative, but if it is 0, the number is
positive. Positive numbers are represented as you may expected, with
regard to binary counting; however, negative numbers are represented
with 2's-compliment. That means, you count backwards &#x2026; sort of.
</p>

<p>
See the example below for the greatest and smallest negative values:
</p>

<div class="org-src-container">

<pre class="src src-c" id="signess">user@si485H-base:demo$ cat signess.c
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> main(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">largest positive signed int: </span>
  <span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">binary: 0111 1111 1111 1111 1111 1111 1111 1111</span>
  <span style="color: #ff7f24;">//     </span><span style="color: #ff7f24;">hex:   7    f     f    f    f    f   f    f</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l_pos</span> = 0x7fffffff;

  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">smallest postivie signed int: </span>
  <span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">binary: 0000 0000  0000 0000 0000 0000 0000 0000</span>
  <span style="color: #ff7f24;">//     </span><span style="color: #ff7f24;">hex:   0   0     0    0    0    0    0    0</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s_pos</span> = 0x00000000;

  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">smallest negative signed int:</span>
  <span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">binary: 1000 0000 0000 0000 0000 0000 0000 0000</span>
  <span style="color: #ff7f24;">//     </span><span style="color: #ff7f24;">hex:   8    0    0     0    0    0    0   0</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s_neg</span> = 0x80000000;


  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">largest negative signed int:</span>
  <span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">binary: 1111 1111 1111 1111 1111 1111 1111 1111</span>
  <span style="color: #ff7f24;">//     </span><span style="color: #ff7f24;">hex:   8    f   f     f    f    f    f   f</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l_neg</span> = 0xffffffff;



  printf(<span style="color: #ffa07a;">" largest positive=%d \t (0x%08x)\n"</span>,l_pos,l_pos);
  printf(<span style="color: #ffa07a;">"smallest positive=%d \t\t (0x%08x)\n"</span>,s_pos,s_pos);
  printf(<span style="color: #ffa07a;">"\n"</span>);

  printf(<span style="color: #ffa07a;">" largest negative=%d \t\t (0x%08x)\n"</span>,l_neg,l_neg);
  printf(<span style="color: #ffa07a;">"smallest negative=%d \t (0x%08x)\n"</span>,s_neg,s_neg);
  printf(<span style="color: #ffa07a;">"\n"</span>);

}
</pre>
</div>
<pre class="example">
user@si485H-base:demo$ ./signess 
 largest positive=2147483647 	 (0x7fffffff)
smallest positive=0 		 (0x00000000)

 largest negative=-1 		 (0xffffffff)
smallest negative=-2147483648 	 (0x80000000)
</pre>
<p>
If we were to count in twos-complement with negative numbers, we start
at 0xffffffff (-1) and go to 0x80000000 (-2147483648). This where the
counting backwards comes from, except we are counting backwards in the
lower 31 bits. The program below shows this clearly:
</p>

<div class="org-src-container">

<pre class="src src-c" id="twos-comp"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s_neg</span> = 0x80000000;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l_neg</span> = 0xffffffff;

  printf(<span style="color: #ffa07a;">"largest negative  =%d \t\t(0x%08x)\n"</span>,l_neg,l_neg);
  printf(<span style="color: #ffa07a;">"largest negative-1=%d \t\t(0x%08x)\n"</span>,l_neg-1,l_neg-1);
  printf(<span style="color: #ffa07a;">"largest negative-2=%d \t\t(0x%08x)\n"</span>,l_neg-2,l_neg-2);
  printf(<span style="color: #ffa07a;">"largest negative-3=%d \t\t(0x%08x)\n"</span>,l_neg-3,l_neg-3);
  printf(<span style="color: #ffa07a;">"...\n"</span>);
  printf(<span style="color: #ffa07a;">"smallest negative+3=%d (0x%08x)\n"</span>,s_neg+3,s_neg+3);
  printf(<span style="color: #ffa07a;">"smallest negative+2=%d (0x%08x)\n"</span>,s_neg+2,s_neg+2);
  printf(<span style="color: #ffa07a;">"smallest negative+1=%d (0x%08x)\n"</span>,s_neg+1,s_neg+1);
  printf(<span style="color: #ffa07a;">"smallest negative  =%d (0x%08x)\n"</span>,s_neg,s_neg);

}
</pre>
</div>
<pre class="example">
user@si485H-base:demo$ ./twos-comp
largest negative  =-1 		(0xffffffff)
largest negative-1=-2 		(0xfffffffe)
largest negative-2=-3 		(0xfffffffd)
largest negative-3=-4 		(0xfffffffc)
...
smallest negative+3=-2147483645 (0x80000003)
smallest negative+2=-2147483646 (0x80000002)
smallest negative+1=-2147483647 (0x80000001)
smallest negative  =-2147483648 (0x80000000)
</pre>

<p>
Of course, as with all data in C, how we interpret ones and zeros is
really in the eye of the beholder. If we were to instead interpret
these values as <b>unsigned</b>, then we get very different output:
</p>

<div class="org-src-container">

<pre class="src src-c" id="unsigned.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s_neg</span> = 0x80000000;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l_neg</span> = 0xffffffff;

  printf(<span style="color: #ffa07a;">"(unsigned) largest negative  =%u \t\t(0x%08x)\n"</span>,l_neg,l_neg);
  printf(<span style="color: #ffa07a;">"(unsigned)  largest negative-1=%u \t\t(0x%08x)\n"</span>,l_neg-1,l_neg-1);
  printf(<span style="color: #ffa07a;">"(unsigned) largest negative-2=%u \t\t(0x%08x)\n"</span>,l_neg-2,l_neg-2);
  printf(<span style="color: #ffa07a;">"(unsigned) largest negative-3=%u \t\t(0x%08x)\n"</span>,l_neg-3,l_neg-3);
  printf(<span style="color: #ffa07a;">"...\n"</span>);
  printf(<span style="color: #ffa07a;">"(unsigned) smallest negative+3=%u (0x%08x)\n"</span>,s_neg+3,s_neg+3);
  printf(<span style="color: #ffa07a;">"(unsigned) smallest negative+2=%u (0x%08x)\n"</span>,s_neg+2,s_neg+2);
  printf(<span style="color: #ffa07a;">"(unsigned) smallest negative+1=%u (0x%08x)\n"</span>,s_neg+1,s_neg+1);
  printf(<span style="color: #ffa07a;">"(unsigned) smallest negative  =%u (0x%08x)\n"</span>,s_neg,s_neg);

}
</pre>
</div>
<pre class="example">
user@si485H-base:demo$ ./unsigned 
(unsigned) largest negative  =4294967295  (0xffffffff)
(unsigned) largest negative-1=4294967294  (0xfffffffe)
(unsigned) largest negative-2=4294967293  (0xfffffffd)
(unsigned) largest negative-3=4294967292  (0xfffffffc)
...
(unsigned) smallest negative+3=2147483651 (0x80000003)
(unsigned) smallest negative+2=2147483650 (0x80000002)
(unsigned) smallest negative+1=2147483649 (0x80000001)
(unsigned) smallest negative  =2147483648 (0x80000000)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Pointers and Memory References</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Pointers Basic</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Pointers (or memory references) are crucial for C programs. Some
terminology for the syntax of pointers:
</p>

<ul class="org-ul">
<li><code>int * p</code> : <i>declaring</i> an integer pointer <code>p</code>. 
</li>
<li>The <i>value</i> or <i>pointer value</i> of <code>p</code> is a memory reference, an
address of a memory value.
</li>
<li><code>*p</code> : <i>de-referencing</i> means to <i>follow the pointer</i> to the memory
referenced by <code>p</code> and change the memory value there. 
</li>
<li><code>&amp;a</code> : <i>address of</i> the variable a, which is a <i>pointer value</i>
since it a memory reference.
</li>
</ul>

<p>
The best way to get a feeling for this is to see it in action:
</p>

<div class="org-src-container">

<pre class="src src-c" id="reference.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 10;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span> = 20;
  <span style="color: #98fb98;">int</span> * <span style="color: #eedd82;">p</span> = &amp;a; <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">MARK 1</span>

  *p = b; <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">MARK 2</span>

  p = &amp;b;
  b = 50; <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">MARK 3</span>

  printf(<span style="color: #ffa07a;">"a=%d &amp;a=%p\n"</span>,a,&amp;a);
  printf(<span style="color: #ffa07a;">"b=%d &amp;b=%p\n"</span>,b,&amp;b);
  printf(<span style="color: #ffa07a;">"p=%p &amp;p=%p *p=%d\n"</span>,p,&amp;p,*p);

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
We can analyze this using a memory diagram for each of the marks. We
use arrows to indicate a memory reference.
</p>

<pre class="example">
 MARK 1            Mark 2           Mark 3

.----.----.       .----.----.      .----.----.
| a  | 10 |&lt;-.    | a  | 20 |&lt;-.   | a  | 20 |
|----+----|  |    |----+----|  |   |----+----|
| b  | 20 |  |    | b  | 20 |  |   | b  | 50 |&lt;-.
|----+----|  |    |----+----|  |   |----+----|  |
| p  |  --+--'    | p  |  --+--'   | p  |  --+--'
'----'----'       '----'----'      '----'----'
</pre>

<p>
And, we can see the last mark is the case when we run the program.
</p>

<pre class="example">
user@si485H-base:demo$ ./reference 
a=20 &amp;a=0xbfd00ebc
b=50 &amp;b=0xbfd00eb8
p=0xbfd00eb8 &amp;p=0xbfd00eb4 *p=50
</pre>

<p>
Notice, though, that the pointer values or memory references are
really just numbers. Really, the way we should model this diagram is
with the full references and values, for the end state:
</p>

<pre class="example">
     address     value
  .------------.------------.
a | 0xbfaebd9c |  20        |
  |------------+------------|
b | 0xbfd00eb8 |  50        | &lt;-.
  |------------+------------|   |
p | 0xbfd00eb4 | 0xbfd00eb8 | --'
  '------------'------------'
</pre>
</div>
</div>


<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Randomization of Memory</h3>
<div class="outline-text-3" id="text-2-2">
<p>
One thing that will trip you up is that on most modern linux install,
each run of the program will randomize the address space. The reason
for this will be clear later, but the implications is that when your
run the program again, you'll get different values.
</p>

<pre class="example">
user@si485H-base:demo$ ./reference 
a=20 &amp;a=0xbfaebd9c
b=20 &amp;b=0xbfaebd98
p=0xbfaebd98 &amp;p=0xbfaebd94 *p=50
</pre>

<p>
To ensure that this will not be the case, you'll have to turn this
feature off. Here's how to do that.
</p>

<pre class="example">
user@si485H-base:demo$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
</pre>

<p>
Now, when you run the program, you'll get the same output ever time.
</p>

<pre class="example">
user@si485H-base:demo$ ./reference 
a=20 &amp;a=0xbffff6bc
b=20 &amp;b=0xbffff6b8
p=0xbffff6b8 &amp;p=0xbffff6b4 *p=50
user@si485H-base:demo$ ./reference 
a=20 &amp;a=0xbffff6bc
b=20 &amp;b=0xbffff6b8
p=0xbffff6b8 &amp;p=0xbffff6b4 *p=50
user@si485H-base:demo$
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Arrays and Strings</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Array Values and Pointers are the same thing!</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Here is a fact: pointers and array values are the same thing. Hold
this truth to be self evident, and you will never be lost in the dark
forest of memory &#x2026;
</p>

<p>
Why is this truth true? Well it has to do with the definition of an
array. An <code>array</code> is a contiugous memory block of a sequence of
similarly typed data types. An array is a reference to the first data
item in the contiguous memory block, and thus an array's value
references memory. That means an array value is a pointer. Boom! 
</p>

<p>
If that is not so clear, let's look at an example.
</p>

<div class="org-src-container">

<pre class="src src-c" id="arrays.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[] = {10,11,12,13,14};

  <span style="color: #98fb98;">int</span> * <span style="color: #eedd82;">p</span> = a;

  p[2] = 5;

  printf(<span style="color: #ffa07a;">"a=%p p=%p\n"</span>,a,p);

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span>(i=0;i&lt;5;i++){
    printf(<span style="color: #ffa07a;">"a[%d] = %d\n"</span>,i,a[i]);
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>


<p>
Here, an array <code>a</code> is declared with 5 values, and we allow the pointer
<code>p</code> to hold the same value as a. Wait! Notice, that we did not use <code>&amp;</code>
to set the value of <code>p</code>. This is a straight assignment, so the value
in <code>a</code> is already a memory reference to an integer because that is the
kind of data that <code>p</code> stores.
</p>

<p>
Next, notice that this line:
</p>
<div class="org-src-container">

<pre class="src src-c">p[2] = 5;
</pre>
</div>
<p>
We are using the array index operator <code>[ ]</code> with <code>p</code>, so in a very
real sense, we are treating <code>p</code> as an array. And, the operation does
as we would expect in the output.
</p>

<pre class="example">
user@si485H-base:demo$ ./arrays 
a=0xbffff6b4 p=0xbffff6b4
a[0] = 10
a[1] = 11
a[2] = 5
a[3] = 13
a[4] = 14
</pre>


<p>
This begs the question: What is the array index operator anyway? It's
a special deference that adds the index to the base. For example:
</p>

<pre class="example">
p[i]  &lt;-- same as ---&gt;   *(p+i)
</pre>

<p>
You can see this to be true in the following example:
</p>

<div class="org-src-container">

<pre class="src src-c" id="p_arrays.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[] = {10,11,12,13,14};

  <span style="color: #98fb98;">int</span> * <span style="color: #eedd82;">p</span> = a;

  *(p+2) = 5;

  printf(<span style="color: #ffa07a;">"a=%p p=%p\n"</span>,a,p);

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span>(i=0;i&lt;5;i++){
    printf(<span style="color: #ffa07a;">"a+%d=%p *(a+%d) = %d\n"</span>,i,a+i,i,a[i]);
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<pre class="example">
user@si485H-base:demo$ ./p_arrays 
a=0xbffff6b4 p=0xbffff6b4
a+0=0xbffff6b4 *(a+0) = 10
a+1=0xbffff6b8 *(a+1) = 11
a+2=0xbffff6bc *(a+2) = 5
a+3=0xbffff6c0 *(a+3) = 13
a+4=0xbffff6c4 *(a+4) = 14
</pre>

<p>
Ok, so if array values and pointers the same, why do we have array
values? Well, I lied, just a bit. Array values and pointers are the
same in the sense that they are both memory references, but the
declaration of an array and the declaration of a pointer are <b>not</b> the
same. When you declare an array, you are declare a region of memory
all at once, and you must be able to always reference that memory,
otherwise you'll have a memory leak. That is, an array value is
immutable or constant &#x2014; it cannot change. 
</p>

<p>
When you declare a pointer, on the other hand, you are creating a
variable whose value reference memory, but the memory it references
can change. 
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Pointer Arithmetic</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Let's take a closer look at the last output:
</p>

<pre class="example">
user@si485H-base:demo$ ./p_arrays 
a=0xbffff6b4 p=0xbffff6b4
a+0=0xbffff6b4 *(a+0) = 10
a+1=0xbffff6b8 *(a+1) = 11
a+2=0xbffff6bc *(a+2) = 5
a+3=0xbffff6c0 *(a+3) = 13
a+4=0xbffff6c4 *(a+4) = 14
</pre>

<p>
Notice the memory reference on each incrimination. While we are adding
just 1 to the value a, the resulting memory reference is changing
by 4. That is because each integer is four bytes wide, so the computer
has to shift each array index reference by the size of the data types
stored within the array. 
</p>

<p>
Consider the same style program for different types, and this fact
becomes apparent:
</p>

<div class="org-src-container">

<pre class="src src-c" id="pointer_arithemtic.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[] = {10,11,12,13,14};
  <span style="color: #98fb98;">short</span> <span style="color: #eedd82;">s</span>[] = {10,11,12,13,14};
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>[] =  {10,11,12,13,14};

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span>(i=0;i&lt;5;i++){
    printf(<span style="color: #ffa07a;">"a+%d=%p *(a+%d) = %d\n"</span>,i,a+i,i,a[i]);
  }

  printf(<span style="color: #ffa07a;">"\n"</span>);

  <span style="color: #00ffff;">for</span>(i=0;i&lt;5;i++){
    printf(<span style="color: #ffa07a;">"s+%d=%p *(s+%d) = %d\n"</span>,i,s+i,i,s[i]);
  }

  printf(<span style="color: #ffa07a;">"\n"</span>);

  <span style="color: #00ffff;">for</span>(i=0;i&lt;5;i++){
    printf(<span style="color: #ffa07a;">"c+%d=%p *(c+%d) = %d\n"</span>,i,c+i,i,c[i]);
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<pre class="example">
user@si485H-base:demo$ ./pointer_arithemtic 
a+0=0xbffff6a8 *(a+0) = 10
a+1=0xbffff6ac *(a+1) = 11
a+2=0xbffff6b0 *(a+2) = 12
a+3=0xbffff6b4 *(a+3) = 13
a+4=0xbffff6b8 *(a+4) = 14

s+0=0xbffff69e *(s+0) = 10
s+1=0xbffff6a0 *(s+1) = 11
s+2=0xbffff6a2 *(s+2) = 12
s+3=0xbffff6a4 *(s+3) = 13
s+4=0xbffff6a6 *(s+4) = 14

c+0=0xbffff699 *(c+0) = 10
c+1=0xbffff69a *(c+1) = 11
c+2=0xbffff69b *(c+2) = 12
c+3=0xbffff69c *(c+3) = 13
c+4=0xbffff69d *(c+4) = 14
</pre>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Strings</h3>
<div class="outline-text-3" id="text-3-3">
<p>
C-strings(!!!!) the bane of student programmers world wide, but they
are not really that bad if you remember that string is simply an array
of characters that is null terminated. In its most pedantic usage, we
can declare a string as an array in the standard sense.
</p>

<div class="org-src-container">

<pre class="src src-c" id="chararray.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[] = {<span style="color: #ffa07a;">'H'</span>,<span style="color: #ffa07a;">'e'</span>,<span style="color: #ffa07a;">'l'</span>,<span style="color: #ffa07a;">'l'</span>,<span style="color: #ffa07a;">'o'</span>,<span style="color: #ffa07a;">' '</span>,<span style="color: #ffa07a;">'W'</span>,<span style="color: #ffa07a;">'o'</span>,<span style="color: #ffa07a;">'r'</span>,<span style="color: #ffa07a;">'l'</span>,<span style="color: #ffa07a;">'d'</span>,<span style="color: #ffa07a;">'!'</span>,<span style="color: #ffa07a;">'\n'</span>,<span style="color: #ffa07a;">'\0'</span>};

  printf(<span style="color: #ffa07a;">"%s"</span>,str);

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
However, this is a huge burden, so in C, we can use the double-quote
mark to declare strings which automatically creates the array and null
terminates. As below:
</p>


<div class="org-src-container">

<pre class="src src-c" id="string.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[] = <span style="color: #ffa07a;">"Hello World!\n"</span>;

  printf(<span style="color: #ffa07a;">"%s"</span>,str);

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
Notice, that when we declare a string with double-quotes, we still
have to declare the variable that references the string as an array
type (or a pointer type) that's because it is still an array. 
</p>

<p>
And, like arrays of integer, we can still reference individual items
in the array using pointer iteration. It is also typical with strings
to leverage the fact that it is NULL terminated. NULL is just a
pseudonym for 0, which is a false value. 
</p>

<div class="org-src-container">

<pre class="src src-c" id="string_iterate.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>[]){

  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[] = <span style="color: #ffa07a;">"Hello World!\n"</span>;
  <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">c</span>;

  <span style="color: #00ffff;">for</span>( c = str;*c; c++){
    putchar(*c);
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Program Memory Layout</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Cowboys and Endian-s</h3>
<div class="outline-text-3" id="text-4-1">
<p>
If you think about it, there are two very different fundamental ways
to organize bytes with meaning. As western language thinkers and
learning, we assign meaning from left to right. For example, if I
wrote down the number:
</p>

<div class="center">
<p>
210500
</p>
</div>

<p>
That is the number two-hundred-and-ten thousand, five hundred. It is
not the number five thousand and twelve (reading the number right to
left).
</p>

<p>
Where the most-significant byte is represented is referred to as
<i>endian-ness</i> in computer science. By far the most prevalent
representation is <i>little endian</i>, by which the <b>least significant
bytes come first</b>. This is in opposition to <i>big endian</i>, which is how
we think of things, where the most significant byte comes first.
</p>

<p>
The impact of this becomes clear with a simple program below. 
</p>

<div class="org-src-container">

<pre class="src src-c" id="endian.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">argv</span>){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 0xdeadbeef;

  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">treat the integer like a array of one-byte values</span>
  <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">p</span> = (<span style="color: #98fb98;">char</span> *) &amp;a;

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span>(i=0;i&lt;4;i++){
    printf(<span style="color: #ffa07a;">"p[%d] = 0x%hhx\n"</span>,i,p[i]);
  }

  <span style="color: #00ffff;">return</span> 0;

}
</pre>
</div>

<p>
Here, we treat the integer <code>a</code> as a buffer of 4-bytes. If we write
those bytes out indexed from 0 to 3, we see that the number 0xdeadbeef
is written out in reveres, 0xef, 0xbe, 0xad, 0xde.
</p>

<pre class="example">
user@si485H-base:demo$ ./endian 
p[0] = 0xef
p[1] = 0xbe
p[2] = 0xad
p[3] = 0xde
</pre>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Stack, Heap, Data, BSS</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now that we have a decent sense of how we interact with memory, let's
spend some time looking at the memory address layout. The big question
is, when we declare a variable/value/data, where is that data located?
</p>

<p>
To start, we need to remind ourselves of the <b>virtual address space</b>,
which allows a single program to treat the entire available memory
space in an ordered way, from high to low addresses. In reality, the
memory is stored in physical RAM in random locations, but from the
program's perspective, it's all lined up.
</p>

<p>
When a program is loaded into memory, there are different regions for
different kinds of data. A key concept, though, is that the program's
data and its code all reside in memory together, which is what we will
leverage when we exploit programs later. 
</p>

<p>
Here are the general areas of the program memory layout, from higher
address to lower address. Note that this is a 32-bit memory addresses,
so there is total of about 4GB in the memory space.
</p>
<pre class="example">
higher address
0xffffffff --&gt; .----------------.
               |    reserved    |  &lt;-- command line args
               +----------------+      envirment variables
               |                |
               |     stack      |  &lt;-- user stack, function frames
               |       |        |
               :       |        :
               '       v        '
                                   &lt;-- mapped data
               .       ^        .
               :       |        :
               |       |        |
               |     heap       |  &lt;-- user heap, dynamic memory
               +----------------+
               |      bss       |  &lt;-- global memory 
               +----------------+
               |     text       |  &lt;-- code segments
0x00000000 --&gt; '----------------'
lower address
</pre>

<p>
Here's what each of these sections are used for:
</p>

<ul class="org-ul">
<li><i>reserved</i>: the reserved space is used for passing enviroment
variables and command line arguments to the program.
</li>
<li><i>stack</i>: the stack is for organizing the execution of the program
into stack frames for tracing functions and local variables. Each
function call <i>pushes</i> a stack fram. from on the stack, and each
return <i>pops</i> off a stack frame. The stack grows towards lower
addresses, into empty memory address space.
</li>
<li><i>heap</i> : the heap is for dynamic, global memory allocations, such as
called from <code>malloc()</code>
</li>
<li><i>bss</i> : the bss is used to store gloabl or stacically declared vaues
</li>
<li><i>text</i> : is where the program code, i.e., the x86 instructions, is stored.
</li>
</ul>

<p>
We can see each of these memory locations in the following program:
</p>

<div class="org-src-container">

<pre class="src src-c" id="mem_layout.c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">foo</span>(<span style="color: #98fb98;">void</span>) { <span style="color: #00ffff;">return</span>; }

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argp</span>[], <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">envp</span>[]){

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 10;

  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">stack_str</span>[] = <span style="color: #ffa07a;">"Hello"</span>;

  <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">heap_str</span> = malloc(strlen(stack_str)+1);
  strcpy(heap_str,stack_str);

  <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">bss_str</span> = <span style="color: #ffa07a;">"World"</span>;



  printf(<span style="color: #ffa07a;">"(reserved)   evnp = 0x%08x \n"</span>, envp);
  printf(<span style="color: #ffa07a;">"(stack)        &amp;a = 0x%08x \n"</span>, &amp;a);
  printf(<span style="color: #ffa07a;">"(stack) stack_str = 0x%08x \n"</span>, stack_str);
  printf(<span style="color: #ffa07a;">"(heap)   heap_str = 0x%08x \n"</span>, heap_str);
  printf(<span style="color: #ffa07a;">"(bss)     bss_str = 0x%08x \n"</span>, bss_str);
  printf(<span style="color: #ffa07a;">"(text)       main = 0x%08x \n"</span>, main);
  printf(<span style="color: #ffa07a;">"(text)        foo = 0x%08x \n"</span>, foo);
}
</pre>
</div>
<pre class="example">
user@si485H-base:demo$ ./mem_layout 
(reserved)   evnp = 0xbffff77c 
(stack)        &amp;a = 0xbffff6c4 
(stack) stack_str = 0xbffff6be 
(heap)   heap_str = 0x0804b008 
(bss)     bss_str = 0x08048630 
(text)       main = 0x080484b3 
(text)        foo = 0x080484ad
</pre>
</div>
</div>
</div>
</div>
</body>
</html>